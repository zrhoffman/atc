#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#
- name: Get TO Cookie
  uri:
    url: "{{ dl_to_url }}/api/{{ dl_to_api_version }}/user/login"
    method: POST
    body: '{ "u":"{{ dl_to_user }}", "p":"{{ dl_to_user_password }}" }'
    headers:
      Content-Type: "application/x-www-form-urlencoded"
  register: dl_mojo_token
  no_log: true

- name: Collect All CDN delegations assigned to Traffic Routers
  set_fact:
    tmp_cdnDelegation: "{{ hostvars[item]['cdn'] }}"
  with_items: "{{groups['traffic_router']}}"
  register: tmp_cdnDelegation_result

- name: Convert CDN Delegation facts to more usable list
  set_fact:
    cdnDelegationList: "{{ tmp_cdnDelegation_result.results | map(attribute='ansible_facts.tmp_cdnDelegation') | difference(excluded_cdn) | list | unique }}"
  vars:
    excluded_cdn: ALL

- name: Get Primary CDN Delegation
  set_fact:
    cdnDelegationPrimary: "{{ cdnDelegationList | first }}"

- name: Get All CDNs
  uri:
    url: "{{ dl_to_url }}/api/{{ dl_to_api_version }}/cdns"
    method: GET
  register: get_all_cdns

- name: Update the Primary CDN
  uri:
    url: "{{ dl_to_url }}/api/{{ dl_to_api_version }}/cdns/{{ get_all_cdns.json | to_json | from_json | json_query(cdn_query) }}"
    method: PUT
    body: "{{ lookup('template', 'cdn.j2') }}"
  vars:
    name: "{{ dl_ds_merged_cdns[cdnDelegationPrimary].name | default(cdnDelegationPrimary) }}"
    domainName: "{{ cdnDelegationPrimary }}.{{ (groups['traffic_ops'] | first).split('.')[1:] | join('.') | lower }}"
    dnssecEnabled: "{{ dl_ds_merged_cdns[cdnDelegationPrimary].dnssecEnabled | default(false) | lower }}"
    cdn_query: "response[?starts_with(domainName,`{{ cdnDelegationPrimary | lower }}`) == `true`].id | [0]"
    error_query: "alerts[?level=='error'].text[?!contains(@,'already exists')]"
  register: update_cdn_out
  failed_when: (update_cdn_out.status == 400 and update_cdn_out.json | to_json | from_json | json_query(error_query) | length != 0) or (update_cdn_out.status > 400 and update_cdn_out.status < 600)

- name: Create additional CDNs having delegations
  uri:
    url: "{{ dl_to_url }}/api/{{ dl_to_api_version }}/cdns"
    method: POST
    body: "{{ lookup('template', 'cdn.j2') }}"
  with_items: "{{ cdnDelegationList | difference(cdnDelegationPrimary) | intersect(dl_ds_merged_cdns | list) + cdnDelegationList | difference(dl_ds_merged_cdns | list)}}"
  vars:
    name: "{{ item.name | default(item) }}"
    domainName: "{{ item }}.{{ (groups['traffic_ops'] | first).split('.')[1:] | join('.') }}"
    dnssecEnabled: "{{ dl_ds_merged_cdns[item].dnssecEnabled | default(false) | lower }}"
    error_query: "alerts[?level=='error'].text[?!contains(@,'already exists')]"
  register: create_cdns_out
  failed_when: (create_cdns_out.status == 400 and create_cdns_out.json | to_json | from_json | json_query(error_query) | length != 0) or (create_cdns_out.status > 400 and create_cdns_out.status < 600)

- name: Get All CDNs
  uri:
    url: "{{ dl_to_url }}/api/{{ dl_to_api_version }}/cdns"
    method: GET
  register: get_all_cdns

- name: Assign fqdn to cdn
  set_fact:
    cdn_assignments: "{{ (cdn_assignments | default({})) | combine({ item: hostvars[item].cdn }) }}"
  with_items: "{{ groups['all'] }}"

- name: Get All Tenants
  uri:
    url: "{{ dl_to_url }}/api/{{ dl_to_api_version }}/tenants"
    method: GET
  register: get_all_tenants

- name: Get All Roles
  uri:
    url: "{{ dl_to_url }}/api/{{ dl_to_api_version }}/roles"
    method: GET
  register: get_all_roles

- name: Create Types
  uri:
    url: "{{ dl_to_url }}/api/{{ dl_to_api_version }}/types"
    method: POST
    body:
      name: "{{ item.name }}"
      description: "{{ item.description }}"
      useInTable: "{{ item.useInTable }}"
  with_items: "{{ dl_ds_merged_types }}"
  vars:
    error_query: "alerts[?level=='error'].text[?!contains(@,'already exists')]"
  register: create_types_out
  failed_when: (create_types_out.status == 400 and create_types_out.json | to_json | from_json | json_query(error_query) | length != 0) or ( create_types_out.status > 400 and create_types_out.status < 600)

- name: Get All Types
  uri:
    url: "{{ dl_to_url }}/api/{{ dl_to_api_version }}/types"
    method: GET
  register: get_all_types

- name: Create Users
  uri:
    url: "{{ dl_to_url }}/api/{{ dl_to_api_version }}/users"
    method: POST
    body: "{{ lookup('template', 'user.j2') }}"
  with_items: "{{ dl_ds_merged_users }}"
  vars:
    role_query: "response[?name == '{{ item.role | default('read-only') }}'].id | [0]"
    tenant_query: "response[?name == '{{ item.tenant | default('root') }}'].id | [0]"
    error_query: "alerts[?level=='error'].text[?!contains(@,'already exists')]"
    user_password: "{{ item.password | default( lookup('password', '/dev/null length=32 chars=ascii_letters') ) }}"
    addressLine1: "{{ item.addressLine1 | default(omit) }}"
    addressLine2: "{{ item.addressLine2 | default(omit) }}"
    city: "{{ item.city | default(omit) }}"
    confirmLocalPasswd: "{{ user_password }}"
    company: "{{ item.company | default(omit) }}"
    email: "{{ item.email }}"
    fullName: "{{ item.fullName }}"
    localPasswd: "{{ user_password }}"
    newUser: "{{ item.newUser | default(omit) }}"
    phoneNumber: "{{ item.phoneNumber | default(omit) }}"
    postalCode: "{{ item.postalCode | default(omit) }}"
    publicSshKey: "{{ item.publicSshKey | default(omit) }}"
    role: "{{ get_all_roles.json | json_query(role_query) }}"
    stateOrProvince: "{{ item.stateOrProvince | default(omit) }}"
    tenantId: "{{ get_all_tenants.json | json_query(tenant_query) | default(omit) }}"
    username: "{{ item.username }}"
  register: create_user_out
  #no_log: true
  failed_when: (create_user_out.status == 400 and create_user_out.json | to_json | from_json | json_query(error_query) | length != 0) or (create_user_out.status > 400 and create_user_out.status < 600)

- name: Get All Users
  uri:
    url: "{{ dl_to_url }}/api/{{ dl_to_api_version }}/users"
    method: GET
  register: get_all_users

- name: Create Cachegroups - Traffic Router
  uri:
    url: "{{ dl_to_url }}/api/{{ dl_to_api_version }}/cachegroups"
    method: POST
    body: "{{ lookup('template', 'cachegroup.j2') }}"
  with_items: "{{ dl_ds_merged_cachegroups | json_query(type_filter) }}"
  vars:
    type_query: "response[?name == '{{ item.type | default('EDGE_LOC') }}'].id | [0]"
    type_filter: "[?type == 'TR_LOC']"
    error_query: "alerts[?level=='error'].text[?!contains(@,'already exists')]"
  register: create_cachegroup_out
  failed_when: (create_cachegroup_out.status == 400 and create_cachegroup_out.json | to_json | from_json | json_query(error_query) | length != 0) or (create_cachegroup_out.status > 400 and create_cachegroup_out.status < 600 and create_cachegroup_out.status != 500)

- name: Create Cachegroups - Infrastructure Tier
  uri:
    url: "{{ dl_to_url }}/api/{{ dl_to_api_version }}/cachegroups"
    method: POST
    body: "{{ lookup('template', 'cachegroup.j2') }}"
  with_items: "{{ dl_ds_merged_cachegroups | json_query(type_filter) }}"
  vars:
    type_query: "response[?name == '{{ item.type | default('EDGE_LOC') }}'].id | [0]"
    type_filter: "[?type == 'TC_LOC']"
    error_query: "alerts[?level=='error'].text[?!contains(@,'already exists')]"
  register: create_cachegroup_out
  failed_when: (create_cachegroup_out.status == 400 and create_cachegroup_out.json | to_json | from_json | json_query(error_query) | length != 0) or (create_cachegroup_out.status > 400 and create_cachegroup_out.status < 600 and create_cachegroup_out.status != 500)

- name: Create Cachegroups - Origin Tier
  uri:
    url: "{{ dl_to_url }}/api/{{ dl_to_api_version }}/cachegroups"
    method: POST
    body: "{{ lookup('template', 'cachegroup.j2') }}"
  with_items: "{{ dl_ds_merged_cachegroups | json_query(type_filter) }}"
  vars:
    type_query: "response[?name == '{{ item.type | default('EDGE_LOC') }}'].id | [0]"
    type_filter: "[?type == 'ORG_LOC']"
    error_query: "alerts[?level=='error'].text[?!contains(@,'already exists')]"
  register: create_cachegroup_out
  failed_when: (create_cachegroup_out.status == 400 and create_cachegroup_out.json | to_json | from_json | json_query(error_query) | length != 0) or (create_cachegroup_out.status > 400 and create_cachegroup_out.status < 600 and create_cachegroup_out.status != 500)

- name: Get All Cachegroups - Origin Tier
  uri:
    url: "{{ dl_to_url }}/api/{{ dl_to_api_version }}/cachegroups"
    method: GET
  register: get_all_cachegroups

- name: Create Cachegroups - Mid Tier
  uri:
    url: "{{ dl_to_url }}/api/{{ dl_to_api_version }}/cachegroups"
    method: POST
    body: "{{ lookup('template', 'cachegroup.j2') }}"
  with_items: "{{ dl_ds_merged_cachegroups | json_query(type_filter) }}"
  vars:
    type_query: "response[?name == '{{ item.type | default('EDGE_LOC') }}'].id | [0]"
    parent_query: "response[?name == '{{ item.parentCachegroup }}'].id | [0]"
    secondaryparent_query: "response[?name == '{{ item.secondaryParentCachegroup }}'].id | [0]"
    parentCachegroupId: "{{ get_all_cachegroups.json | json_query(parent_query) | default(omit) }}"
    secondaryparentCachegroupId: "{{ get_all_cachegroups.json | json_query(secondaryparent_query) | default(omit) }}"
    type_filter: "[?type == 'MID_LOC']"
    error_query: "alerts[?level=='error'].text[?!contains(@,'already exists')]"
  register: create_cachegroup_out
  failed_when: (create_cachegroup_out.status == 400 and create_cachegroup_out.json | to_json | from_json | json_query(error_query) | length != 0) or (create_cachegroup_out.status > 400 and create_cachegroup_out.status < 600 and create_cachegroup_out.status != 500)

- name: Get All Cachegroups - Mid Tier
  uri:
    url: "{{ dl_to_url }}/api/{{ dl_to_api_version }}/cachegroups"
    method: GET
  register: get_all_cachegroups

- name: Create Cachegroups - Edge Tier
  uri:
    url: "{{ dl_to_url }}/api/{{ dl_to_api_version }}/cachegroups"
    method: POST
    body: "{{ lookup('template', 'cachegroup.j2') }}"
  with_items: "{{ dl_ds_merged_cachegroups | json_query(type_filter) }}"
  vars:
    type_query: "response[?name == '{{ item.type | default('EDGE_LOC') }}'].id | [0]"
    parent_query: "response[?name == '{{ item.parentCachegroup }}'].id | [0]"
    secondaryparent_query: "response[?name == '{{ item.secondaryParentCachegroup }}'].id | [0]"
    parentCachegroupId: "{{ get_all_cachegroups.json | json_query(parent_query) | default(omit) }}"
    secondaryparentCachegroupId: "{{ get_all_cachegroups.json | json_query(secondaryparent_query) | default(omit) }}"
    type_filter: "[?type == 'EDGE_LOC']"
    error_query: "alerts[?level=='error'].text[?!contains(@,'already exists')]"
  register: create_cachegroup_out
  failed_when: (create_cachegroup_out.status == 400 and create_cachegroup_out.json | to_json | from_json | json_query(error_query) | length != 0) or (create_cachegroup_out.status > 400 and create_cachegroup_out.status < 600 and create_cachegroup_out.status != 500)

- name: Get All Cachegroups
  uri:
    url: "{{ dl_to_url }}/api/{{ dl_to_api_version }}/cachegroups"
    method: GET
  register: get_all_cachegroups

- name: Associate cachegroups to phys_locations
  command: "{{ role_path }}/files/selection.set.py {{ item | quote }} {{ dl_ds_merged_divisions | json_query(physlocation_query) | join(',') | quote }}"
  register: cachegroup_physlocations_out
  changed_when: false
  with_items: "{{ dl_ds_merged_divisions | json_query(cachegroup_query) | unique }}"
  vars:
    cachegroup_query: "[*].regions[*].phys_locations[*].cachegroups[][][]"
    physlocation_query: "[*].regions[*].phys_locations[?contains(cachegroups,'{{ item }}')].name[][]"

- name: Massage cachegroup to phys_location mappings
  set_fact:
    physlocation_tmp_str: "{% for i in cachegroup_physlocations_out.results %}{{ i.stdout | from_json | to_json }}{% if not loop.last %}|{% endif %}{%endfor%}"

- name: Build temporary association of cachegroup to region
  set_fact:
    phys_location_tmp_dict: "{{ (phys_location_tmp_dict| default({})) | combine(item | from_json) }}"
  with_items: "{{ physlocation_tmp_str.split('|') }}"

- name: Associate origins to cachegroups
  command: "{{ role_path }}/files/selection.set.py {{ dl_ds_merged_cachegroups | selectattr('type', 'equalto', 'ORG_LOC') | map(attribute='name') | join(',') | quote }} {{ groups['fakeorigin'] | union(groups['mso_parent_alias']) | join(',') | quote }}"
  register: cachegroup_origin_out
  changed_when: false

- name: Associate edge caches to cachegroups
  command: "{{ role_path }}/files/selection.set.py {{ dl_ds_merged_cachegroups | selectattr('type', 'equalto', 'EDGE_LOC') | map(attribute='name') | join(',') | quote }} {{ groups['atsec'] | union(groups['grove']) | join(',') | quote }}"
  register: cachegroup_edge_out
  changed_when: false

- name: Associate mid caches to cachegroups
  command: "{{ role_path }}/files/selection.set.py {{ dl_ds_merged_cachegroups | selectattr('type', 'equalto', 'MID_LOC') | map(attribute='name') | join(',') | quote }} {{ groups['atsmid'] | join(',') | quote }}"
  register: cachegroup_mid_out
  changed_when: false

- name: Associate traffic routers to cachegroups
  command: "{{ role_path }}/files/selection.set.py {{ dl_ds_merged_cachegroups | selectattr('type', 'equalto', 'TR_LOC') | map(attribute='name') | join(',') | quote }} {{ groups['traffic_router'] | join(',') | quote }}"
  register: cachegroup_tr_out
  changed_when: false

# List of Map of Cachegroup to Host List
- name: Combine cachegroup associations
  set_fact:
    cachegroups_merged_tmp: "{{ cachegroups_merged_tmp | default([]) + [ { 'cachegroup': item.key, 'hosts': item.value.split(',') } ] }}"
  with_dict: "{{ (cachegroup_edge_out.stdout | from_json) | combine(cachegroup_mid_out.stdout | from_json) | combine(cachegroup_tr_out.stdout | from_json) | combine(cachegroup_origin_out.stdout | from_json) }}"

# Map of hosts to cachegroups
- name: Convert cachegroup associations to a more useful format
  set_fact:
    cachegroups_assignments: "{{ cachegroups_assignments | default({}) | combine({ item.1: item.0.cachegroup }) }}"
  with_subelements:
    - "{{ cachegroups_merged_tmp }}"
    - hosts

- name: Hold onto a copy of infrastructure hosts
  set_fact:
    infra_hosts: "{{ groups['all'] | difference(cachegroups_assignments.keys()) }}"

- name: Add remaining hosts to the infrastructure cachegroup
  set_fact:
    cachegroups_assignments: "{{ cachegroups_assignments | default({}) | combine({ item: 'infrastructure' }) }}"
  with_items: "{{ infra_hosts }}"

- name: Add remaining hosts to the infrastructure physical locations
  set_fact:
    cachegroups_merged_tmp: "{{ cachegroups_merged_tmp | default([]) + [{ 'cachegroup': 'infrastructure', 'hosts': infra_hosts }] }}"

- name: Massage cachegroup associations to a forward lookup dictionary
  set_fact:
    cachegroup_lookup: "{{ ( cachegroup_lookup | default({}) ) | combine({ item['cachegroup']: (item['hosts'] | join(',')) }) }}"
  with_items: "{{ cachegroups_merged_tmp }}"

- name: Associate Physical Locations to Servers
  command: "{{ role_path }}/files/selection.set.py {{ phys_location_tmp_dict[item.key] | quote }} {{ item.value | quote }}"
  register: physlocation_caches_out
  changed_when: false
  with_dict: "{{ cachegroup_lookup }}"

- name: Massage phys_location to cache mappings
  set_fact:
    physlocation_cache_tmp_str: "{% for i in physlocation_caches_out.results %}{{ i.stdout | from_json | to_json }}{% if not loop.last %}|{% endif %}{%endfor%}"

- name: Process location map (phase 1)
  set_fact:
    physlocation_cache_tmp_list: "{{ physlocation_cache_tmp_list | default([]) | union( [item  | from_json] ) }}"
  with_items: "{{ physlocation_cache_tmp_str.split('|') }}"

- name: Process location map (phase 2)
  set_fact:
    used_locations: "{{ physlocation_cache_tmp_list | json_query(location_query) | unique }}"
  vars:
    location_query: "[].keys(@)[]"

- name: Process location map (phase 3)
  set_fact:
    tmp_location_map: "{{ (tmp_location_map | default({})) | combine({ item: (physlocation_cache_tmp_list | json_query(location_query) | join(','))}) }}"
  with_items: "{{ used_locations }}"
  vars:
    location_query: "[].\"{{ item }}\""

- name: Assemble assignments of cache to location
  set_fact:
    physlocation_assignments: "{
                              {%- for location, host_csv in tmp_location_map.items() -%}
                              {%- set outer_loop = loop -%}
                              {%- for i in host_csv.split(',') -%}
                              '{{ i }}': '{{ location }}'
                              {%- if not loop.last %},{% endif -%}
                              {%- endfor %}
                              {%- if not outer_loop.last %},{% endif -%}
                              {%- endfor %}
                              }"

- name: Create Division
  uri:
    url: "{{ dl_to_url }}/api/{{ dl_to_api_version }}/divisions"
    method: POST
    body:
      name: "{{ item }}"
  with_items: "{{ dl_ds_merged_divisions | json_query(division_query) }}"
  vars:
    division_query: "[].division_name"
    error_query: "alerts[?level=='error'].text[?!contains(@,'already exists')]"
  register: create_divisions_out
  failed_when: (create_divisions_out.status == 400 and create_divisions_out.json | to_json | from_json | json_query(error_query) | length != 0) or (create_divisions_out.status > 400 and create_divisions_out.status < 600)

- name: Get All Divisions
  uri:
    url: "{{ dl_to_url }}/api/{{ dl_to_api_version }}/divisions"
    method: GET
  register: get_all_divisions

- name: Assemble assignments of region to division
  set_fact:
    region_assignments: "{{ (region_assignments | default({})) | combine(regions) }}"
  with_items: "{{ get_all_divisions.json.response }}"
  vars:
    region_query: "[?division_name == `{{ item.name }}`].regions[].{region_name: region_name, division_id: `{{ item.id }}`}"
    regions: "{{ dl_ds_merged_divisions | to_json | from_json | json_query(region_query) | items2dict(key_name='region_name',value_name='division_id') }}"

- name: Create Regions
  uri:
    url: "{{ dl_to_url }}/api/{{ dl_to_api_version }}/regions"
    method: POST
    body: >
      {
      "name": "{{ item.key }}",
      "division": {{ item.value | int}}
      }
  with_dict: "{{ region_assignments }}"
  vars:
    error_query: "alerts[?level=='error'].text[?!contains(@,'already exists')]"
  register: create_regions_out
  failed_when: (create_regions_out.status == 400 and create_regions_out.json | to_json | from_json | json_query(error_query) | length != 0) or ( create_regions_out.status > 400 and create_regions_out.status < 600)

- name: Get All Regions
  uri:
    url: "{{ dl_to_url }}/api/{{ dl_to_api_version }}/regions"
    method: GET
  register: get_all_regions

- name: Constuct physLocation payload
  set_fact:
    physlocation_list: "{{ physlocation_list | default([]) + [ physlocations ] }}"
  with_items: "{{ get_all_regions.json.response  }}"
  vars:
    physloc_query: "[].regions[?region_name==`{{ item.name }}`][].phys_locations[].{value: {name: name, shortname: shortname, address: address, city: city, state: state, zip: zip, phone: phone, poc: poc, email: email, comments: comments, cachegroups: cachegroups, regionId: `{{ item.id }}`}}"
    physlocations: "{{ dl_ds_merged_divisions | to_json | from_json | json_query(physloc_query)  }}"

- name: Create Physical Locations
  uri:
    url: "{{ dl_to_url }}/api/{{ dl_to_api_version }}/phys_locations"
    method: POST
    body: >
        {
        "address": "{{ item.value.address }}",
        "city": "{{ item.value.city }}",
        "comments": "{{ item.value.comments | default(omit) }}",
        "email": "{{ item.value.email | default(omit) }}",
        "name": "{{ item.value.name }}",
        "phone": "{{ item.value.phone | default(omit) }}",
        "poc": "{{ item.value.poc | default(omit) }}",
        "shortName": "{{ item.value.shortname }}",
        "state": "{{ item.value.state }}",
        "zip": "{{ item.value.zip }}",
        "regionId": {{ item.value.regionId | int }}
        }
  with_items: "{{ physlocation_list }}"
  vars:
    error_query: "alerts[?level=='error'].text[?!contains(@,'already exists')]"
  register: create_physlocation_out
  failed_when: (create_physlocation_out.status == 400 and create_physlocation_out.json | to_json | from_json | json_query(error_query) | length != 0) or ( create_physlocation_out.status > 400 and create_physlocation_out.status < 600)

- name: Get All Physical Locations
  uri:
    url: "{{ dl_to_url }}/api/{{ dl_to_api_version }}/phys_locations"
    method: GET
  register: get_all_physlocations

- name: Assign types to servers
  set_fact:
    type_assignments: "{{ (type_assignments | default({})) | combine({ item: dl_ds_merged_type_ansible_component_map[hostvars[item].component] | default('UNKNOWN') }) }}"
  with_items: "{{ groups['all'] }}"

- name: Assert a default location
  set_fact:
    default_location: dl_ds_merged_divisions | json_query(location_query)
  vars:
    location_query: "[].regions[].phys_locations[].name | [0]"

- name: Assert a default cachegroup
  set_fact:
    default_cachegroup: infrastructure

- name: Get All Profiles
  uri:
    url: "{{ dl_to_url }}/api/{{ dl_to_api_version }}/profiles"
    method: GET
  register: get_all_profiles

- name: Get All Parameters from GLOBAL profile
  uri:
    url: "{{ dl_to_url }}/api/{{ dl_to_api_version }}/profiles/name/GLOBAL/parameters"
    method: GET
  register: get_global_parameters

- name: Unlink all Global Profile parameters to be recreated
  uri:
    url: "{{ dl_to_url }}/api/{{ dl_to_api_version }}/profileparameters/{{ get_all_profiles.json | to_json | from_json | json_query(profile_query) }}/{{ item }}"
    method: DELETE
  with_items: "{{ get_global_parameters.json.response | map(attribute='id') | list }}"
  vars:
    profile_query: "response[?name == 'GLOBAL'].id | [0]"
    error_query: "alerts[?level=='error'].text[?!contains(@,'already exists')]"
  register: unassociate_global_params
  failed_when: (unassociate_global_params.status == 400 and unassociate_global_params.json | to_json | from_json | json_query(error_query) | length != 0) or ( unassociate_global_params.status > 400 and unassociate_global_params.status < 600)

- name: Create Profiles - Global
  uri:
    url: "{{ dl_to_url }}/api/{{ dl_to_api_version }}/profiles"
    method: POST
    body: "{{ lookup('template', 'profile.j2') }}"
  with_items: "{{ dl_ds_merged_profiles }}"
  vars:
    name: "{{ item.name }}"
    description: "{{ item.description }}"
    cdn: "{{ get_all_cdns.json | to_json | from_json | json_query(cdn_query) }}"
    type: "{{ item.type }}"
    routingDisabled: "{{ (item.routingDisabled | default(false)) | lower }}"
    cdn_query: "response[?starts_with(domainName,`{{ item.cdn | default(ALL) | lower }}`) == `true` || name == `{{ item.cdn | default(ALL) }}`].id | [0]"
    error_query: "alerts[?level=='error'].text[?!contains(@,'already exists')]"
  register: create_profiles_out
  failed_when: (create_profiles_out.status == 400 and create_profiles_out.json | to_json | from_json | json_query(error_query) | length != 0) or (create_profiles_out.status > 400 and create_profiles_out.status < 600)

- name: Create and Associate Parameters - Global
  uri:
    url: "{{ dl_to_url }}/api/{{ dl_to_api_version }}/profiles/name/{{ item.name }}/parameters"
    method: POST
    body: "{{ lookup('template', 'parameter.j2') }}"
  with_items:
    - "{{ dl_ds_merged_profiles }}"
  vars:
    cdn_query: "response[?starts_with(domainName,`{{ item.cdn | default(ALL) | lower }}`) == `true` || name == `{{ item.cdn | default(ALL) }}`].id | [0]"
    error_query: "alerts[?level=='error'].text[?!contains(@,'already exists')]"
  register: create_profiles_out
  failed_when: (create_profiles_out.status == 400 and create_profiles_out.json | to_json | from_json | json_query(error_query) | length != 0) or (create_profiles_out.status > 400 and create_profiles_out.status < 600)

- name: Handle Profile & Parameter CDN Templates
  include_tasks: parameter_loader.yml
  vars:
    Target_cdn_delegation_fqdn: "{{ Target_cdn_delegation | default(MKGA) }}.{{ (groups['traffic_ops'] | first).split('.')[1:] | join('.') | lower }}"
    Target_cdn_name: "{{ get_all_cdns.json | to_json | from_json | json_query(cdnName_query) }}"
    Target_cdn_id: "{{ get_all_cdns.json | to_json | from_json | json_query(cdn_query) }}"
    cdnName_query: "response[?starts_with(domainName,`{{ Target_cdn_delegation | lower }}`) == `true`].name | [0]"
    cdn_query: "response[?starts_with(domainName,`{{ Target_cdn_delegation | lower }}`) == `true`].id | [0]"
  with_items: "{{ cdnDelegationList }}"
  loop_control:
    loop_var: Target_cdn_delegation

- name: Get All Profiles
  uri:
    url: "{{ dl_to_url }}/api/{{ dl_to_api_version }}/profiles"
    method: GET
  register: get_all_profiles

- name: Get All Parameters per Profile
  uri:
    url: "{{ dl_to_url }}/api/{{ dl_to_api_version }}/profiles/name/{{ item }}/parameters"
    method: GET
  vars:
    profile_query: "response.id"
  with_items: "{{ get_all_profiles.json.response | map(attribute='name') | list }}"
  register: get_all_parameters_by_profile

- name: Map CDN Delegation to CDN Name
  set_fact:
    delegation_cdnName_map: "{{ (delegation_cdnName_map | default({})) | combine({ (tmp | lower): (item.name | lower) }) }}"
  with_items: "{{ get_all_cdns.json.response }}"
  vars:
    tmp: "{{ (item.domainName == '-') | ternary('ALL', (item.domainName.split('.')[0])) }}"

- name: Map CDN Name to CDN Delegation
  set_fact:
    cdnName_delegation_map: "{{ (delegation_cdnName_map | default({})) | combine({ (item.name | lower): (tmp | lower) }) }}"
  with_items: "{{ get_all_cdns.json.response }}"
  vars:
    tmp: "{{ (item.domainName == '-') | ternary('ALL', (item.domainName.split('.')[0])) }}"

- name: Generate potential mappings between cdn/components and profiles
  set_fact:
    ccp_list: "{{ (ccp_list| default([])) +[{ 'cdnname': item.1, 'component': item.0 , 'profile_keys': profile_keys, 'compound_key': compound_key }] }}"
  with_nested:
    - "{{ dl_ds_merged_profile_prefix_ansible_component_map.keys() | map('lower') | list }}"
    - "{{ lc_cdns | to_json | from_json | json_query(cdn_query) | lower }}"
  vars:
    lc_profiles: "{{ get_all_profiles.json.response | lower }}"
    lc_cdns: "{{ get_all_cdns.json.response | lower }}"
    profile_keys: "{{ lc_profiles | to_json | from_json | json_query(profile_query) }}"
    profile_query: "[?starts_with(name,`{{ dl_ds_merged_profile_prefix_ansible_component_map[item.0] | lower }}`) {% if dl_ds_merged_profile_blacklist_ansible_component_map[item.0] != None %}{% for b in dl_ds_merged_profile_blacklist_ansible_component_map[item.0] %}&& !contains(name,`{{ b | lower }}`) {% endfor %}{% endif %}&& cdnname == `{{ item.1 }}`].name"
    cdn_query: "[].name"
    compound_key: "{{ item.1 }}_{{ item.0 }}"

- name: Fabricate a compound_key for each host based on the cdn/component
  set_fact:
    host_keys_tmp: "{{ host_keys_tmp | default([]) + [{ 'host': item, 'compound_key': compound_key }] }}"
  with_items: "{{ groups['all'] }}"
  vars:
    compound_key: "{{ delegation_cdnName_map[hostvars[item].cdn | lower ] }}_{{ hostvars[item].component | lower }}"

- name: Produce elegible pairings of keys and hosts
  set_fact:
    paired_elegible_keys_hosts: "{{ paired_elegible_keys_hosts | default({}) | combine( { item: { 'hosts': hosts, 'profiles': profile_keys } } ) }}"
  with_items: "{{ compound_keys }}"
  vars:
    compound_key_query: "[].compound_key"
    host_query: "[?compound_key == '{{ item }}'].host"
    key_query: "[?compound_key == '{{ item }}'].profile_keys[]"
    compound_keys: "{{ host_keys_tmp | to_json | from_json | json_query(compound_key_query) | unique }}"
    hosts: "{{ host_keys_tmp | to_json | from_json | json_query(host_query) }}"
    profile_keys: "{{ ccp_list | to_json | from_json | json_query(key_query) }}"

- name: Associate profiles to hosts
  command: "{{ role_path }}/files/selection.set.py {{ paired_elegible_keys_hosts[item].profiles | join(',') | quote }} {{ paired_elegible_keys_hosts[item].hosts | join(',') | quote }}"
  register: profiles_hosts_out
  changed_when: false
  with_items: "{{ paired_elegible_keys_hosts.keys() | list}}"

- name: Massage profiles to hosts
  set_fact:
    profile_host_tmp_str: "{% for i in profiles_hosts_out.results %}{{ i.stdout | from_json | to_json }}{% if not loop.last %}|{% endif %}{%endfor%}"

- name: Process profile map (phase 1)
  set_fact:
    profile_host_tmp_list: "{{ profile_host_tmp_list | default([]) | union( [item  | from_json] ) }}"
  with_items: "{{ profile_host_tmp_str.split('|') }}"

- name: Process profile map (phase 2)
  set_fact:
    used_profiles: "{{ profile_host_tmp_list | json_query(profile_query) | unique }}"
  vars:
    profile_query: "[].keys(@)[]"

- name: Process profile map (phase 3)
  set_fact:
    tmp_profile_map: "{{ (tmp_profile_map | default({})) | combine({ item: (profile_host_tmp_list | json_query(profile_query) | join(','))}) }}"
  with_items: "{{ used_profiles }}"
  vars:
    profile_query: "[].\"{{ item }}\""

- name: Assemble assignments of profiles to hosts
  set_fact:
    profile_assignments: "{
                          {%- for profile, host_csv in tmp_profile_map.items() -%}
                          {%- set outer_loop = loop -%}
                          {%- for i in host_csv.split(',') -%}
                          '{{ i }}': '{{ profile }}'
                          {%- if not loop.last %},{% endif -%}
                          {%- endfor %}
                          {%- if not outer_loop.last %},{% endif -%}
                          {%- endfor %}
                          }"

- name: Get All Server Statuses
  uri:
    url: "{{ dl_to_url }}/api/{{ dl_to_api_version }}/statuses"
    method: GET
  register: get_all_statuses

- name: Get the CDN Assignments into a more queryable form
  set_fact:
    cdn_assignment_reverse_tmp: "{{ cdn_assignment_reverse_tmp | default([]) + [{'host': item.key, 'cdn': item.value}] }}"
  with_dict: "{{ cdn_assignments }}"

- name: Divide TM hosts in half per CDN (Phase 1)
  set_fact:
    tm_status_tmp: "{{ tm_status_tmp | default([]) + [ {'onlineTM': evenTM, 'offlineTM': oddTM} ] }}"
  with_items: "{{ delegation_cdnName_map.keys() }}"
  vars:
    lc_cdn_assignment_reverse_tmp: "{{ cdn_assignment_reverse_tmp | lower }}"
    cdn_query: "[?cdn == `{{ item }}`].host"
    cdns: "{{ lc_cdn_assignment_reverse_tmp | json_query(cdn_query) }}"
    tm_cdns: "{{ groups['traffic_monitor'] | intersect(cdns) }}"
    evenTM: "{{ (groups['traffic_monitor'] | intersect(cdns))[::2] }}"
    oddTM: "{{ (groups['traffic_monitor'] | intersect(cdns))[1::2] }}"

- name: Assign server status for offline traffic monitors
  set_fact:
    status_assignment: "{{ status_assignment | default({}) | combine({ item: 'OFFLINE' }) }}"
  with_items: "{{ tm_status_tmp | json_query(offline_query) }}"
  vars:
    offline_query: "[].offlineTM[]"

- name: Assign server status for online traffic monitors
  set_fact:
    status_assignment: "{{ status_assignment | default({}) | combine({ item: 'ONLINE' }) }}"
  with_items: "{{ tm_status_tmp | json_query(online_query) }}"
  vars:
    online_query: "[].onlineTM[]"

- name: Assign server status for caches
  set_fact:
    status_assignment: "{{ status_assignment | default({}) | combine({ item: 'REPORTED' }) }}"
  with_items: "{{ groups['atsec'] + groups['atsmid'] + groups['grove'] }}"
  
# Due to data manipulation being a shortcome of ansible, in these next set of tasks we are extracting 
# interface data that is needed for server creation for dual homing puposes from ansible facts and 
# storing the final result in dl_all_interfaces var
          
- name: Set tmp var to store all pertinent interfaces data from ansible facts for each host
  set_fact:
    _dl_all_ifaces_tmp_1: "{{ (_dl_all_ifaces_tmp_1 | default([])) + [ifaces] }}"
  loop: "{{ hostvars | to_json | replace(replacestr, '') | from_json | json_query(loop_query) | subelements('all_ifaces') }}"
  loop_control:
    label: "{{ item.0.host_name }} - {{ item.1 }}"
  when: 'ifaces != ""'
  vars:
    loop_query: "* | [].{host_name: inventory_hostname, hostvrs: @, all_ifaces: @.ansible_interfaces || `[]`}" # || used to set default value to empty list
    replacestr: "{{ '{{' }}"
    iface_query: "[ansible_{{ item.1 }}] | [? (ipv4 || ipv6) && length(ipv6[?!starts_with(address,`fe80`) && scope == `global`]) > `0` && (type == `ether` || type == `bonding`)] | [0] | {iface_name: device, v6_addresses: ipv6[?!starts_with(address,`fe80`) && scope == `global`], host: `{{ item.0.host_name }}`, mtu: mtu, v4_address: ipv4}"
    ifaces: "{{ item.0.hostvrs | json_query(iface_query) }}"

- name: Set var to add checks for v6 slaac address and service address to tmp var for all interfaces
  set_fact: 
    _dl_all_ifaces_tmp_2: "{{ _dl_all_ifaces_tmp_2 | default({}) | combine({ host_key: combined_result }) }}"
  loop: "{{ _dl_all_ifaces_tmp_1 | subelements('v6_addresses') }}"
  loop_control:
    label: "{{ item.0.host }} - {{item.1.address}}"
  vars:
    v6_start: "{{ (item.1.address.split(':')[:-1]) | join(':') }}"
    v6_start_regex: "{{ v6_start }}.+"
    v6_addr_list: "{{ item.0.v6_addresses | difference([item.1]) | map(attribute='address') | list }}"
    v6_addr_starts_with: "{{ v6_addr_list | select('match',v6_start_regex) | list }}"
    is_v6_slaac_addr: "{{ true if (v6_addr_list | length > 0) and ( v6_addr_list | select('match',v6_start_regex) | list | length == 0) else false }}"
    default_v6_addr: "{{ hostvars[item.0.host].ipv6_service_address | default(hostvars[item.0.host].ansible_default_ipv6.address) }}"
    is_v6_service_addr: "{{ true if ((item.1.address == default_v6_addr) and (( v6_addr_list | length ) == 0)) or (not is_v6_slaac_addr and ( v6_addr_list | length ) > 0) else false }}"
    tmp_host_key: "{{ item.0.host }}.{{ item.0.iface_name}}"
    host_key: "{{ tmp_host_key | replace('.','_') | replace('-','_') }}" # parsing error using '.' in host_key
    result: "{{ item.1 | combine({'is_v6_slaac_addr': is_v6_slaac_addr, 'is_service_address': is_v6_service_addr}) }}"
    host_query: "{{ host_key }}.host | [0]"
    iface_query: "{{ host_key }}.iface_name | [0]"
    mtu_query: "{{ host_key }}.mtu | [0]"
    v4_addr_query: "{{ host_key }}.v4_address | [0]"
    v6_addr_query: "{{ host_key }}.v6_addresses"
    combined_result:
      host: "{{ (_dl_all_ifaces_tmp_2 | default({})) | json_query(host_query) | default(item.0.host, true) }}"
      iface_name: "{{ (_dl_all_ifaces_tmp_2 | default({})) | json_query(iface_query) | default(item.0.iface_name, true) }}"
      mtu: "{{ (_dl_all_ifaces_tmp_2 | default({})) | json_query(mtu_query) | default(item.0.mtu, true) }}"
      v4_address: "{{ (_dl_all_ifaces_tmp_2 | default({})) | json_query(v4_addr_query) | default(item.0.v4_address, true) }}"
      v6_addresses: "{{ ((_dl_all_ifaces_tmp_2 | default({})) | json_query(v6_addr_query) | default([], true)) + [result] }}"

- name: Set var to add v4 service address check to tmp var for all interfaces
  set_fact:
    _dl_all_ifaces_tmp_3: "{{ (_dl_all_ifaces_tmp_3 | default([])) + [ item | combine({'v4_address': {'is_service_address': is_v4_service_addr } }, recursive=True)] }}"
  loop: "{{ _dl_all_ifaces_tmp_2 | dict2items | map(attribute='value') | list }}"
  loop_control:
    label: "{{ item.host }} - {{ item.iface_name }}"
  vars:
    is_v4_service_addr: "{{ true if item.v4_address.address == hostvars[item.host].ansible_default_ipv4.address else false }}"

- name: Get ip gateway information from shell
  shell: "if [ \"$(`which ip` -{{ item.ip_family }} route show {{ item.address }}/{{ item.suffix }} | grep via)\" == \"\" ]; then `which ip` -{{ item.ip_family }} route show | grep default | grep -vE ' fe80| 127.' | cut -f3 -d' ';else `which ip` -{{ item.ip_family }} route show {{ item.address }}/{{ item.suffix }} | cut -f3 -d' '; fi"
  loop: "{{ _dl_all_ifaces_tmp_3 | json_query(ipObject_query) }}"
  register: ipAddress_gateways
  changed_when: false
  environment:
    PATH: "{{ lookup('env', 'PATH') }}:/usr/local/sbin:/usr/sbin:/sbin"
  vars:
    ipObject_query: "[] | { v4_address: [].{ host: host, address: v4_address.address, suffix: v4_address.netmask, ip_family: `4` }, v6_addresses: [].{ address: @.v6_addresses[0].address, host: host, suffix: @.v6_addresses[0].prefix, ip_family: `6` } } | *[]"
  delegate_to: "{{ item.host }}"

- name: Get interface speed to determine max maxBandwidth
  shell: "cat /sys/class/net/{{ item.iface_name }}/speed"
  loop: "{{ _dl_all_ifaces_tmp_3 | json_query(iface_query) }}"
  register: iface_total_bandwidth
  changed_when: false
  environment:
    PATH: "{{ lookup('env', 'PATH') }}:/usr/local/sbin:/usr/sbin:/sbin"
  vars:
    iface_query: "[].{ host: host, iface_name: iface_name }"
  failed_when: false
  delegate_to: "{{ item.host }}"

- name: Set var for adding v6 gateway information to to tmp var for all interfaces
  set_fact:
    _dl_all_ifaces_tmp_4: "{{ _dl_all_ifaces_tmp_4 | default({}) | combine({ hostAsKey: combined_result }) }}"
  loop: "{{ _dl_all_ifaces_tmp_3 | subelements('v6_addresses') }}"
  loop_control:
    label: "{{ item.0.host }} - {{ item.1.address }}"
  vars:
    v6gateway_query: "[?item.address == `{{ item.1.address }}`] |[0].stdout"
    v6gateway: "{{ (((ipAddress_gateways.results | json_query(v6gateway_query)) if ipAddress_gateways.results | json_query(v6gateway_query) != '' else (v6_cidr_address | ipaddr('1'))).split('/'))[0] }}"
    v6_cidr_address: "{{ item.1.address }}/{{ item.1.prefix }}"
    tmp_hostAsKey: "{{ item.0.host }}.{{ item.0.iface_name }}"
    hostAsKey: "{{ tmp_hostAsKey | replace('.','_') | replace('-','_') }}"
    result: "{{ item.1 | combine({'gateway': v6gateway, 'address': v6_cidr_address}) }}"
    host_query: "{{ hostAsKey }}.host | [0]"
    iface_query: "{{ hostAsKey }}.iface_name | [0]"
    mtu_query: "{{ hostAsKey }}.mtu | [0]"
    v4_address_query: "{{ hostAsKey }}.v4_address | [0]"
    v6_addresses_query: "{{ hostAsKey }}.v6_addresses"
    combined_result:
      host: "{{ (_dl_all_ifaces_tmp_4 | default({})) | json_query(host_query) | default(item.0.host, true) }}"
      iface_name: "{{ (_dl_all_ifaces_tmp_4 | default({})) | json_query(iface_query) | default(item.0.iface_name, true) }}"
      mtu: "{{ (_dl_all_ifaces_tmp_4 | default({})) | json_query(mtu_query) | default(item.0.mtu, true) }}"
      v4_address: "{{ (_dl_all_ifaces_tmp_4 | default({})) | json_query(v4_address_query) | default(item.0.v4_address, true) }}"
      v6_addresses: "{{ ((_dl_all_ifaces_tmp_4 | default({})) | json_query(v6_addresses_query) | default([], true)) + [result] }}"
  
- name: Set var to adding v4 gateway and interface total bandwidth to tmp var for all interfaces
  set_fact:
    _dl_all_ifaces_tmp_5: "{{ _dl_all_ifaces_tmp_5 | default ([]) + [item | combine({'iface_total_bandwidth': totalBandwidth, 'v4_address': {'gateway': v4gateway, 'address': v4_cidr_address } }, recursive=True)] }}"
  loop: "{{ _dl_all_ifaces_tmp_4 | dict2items | map(attribute='value') | list }}"
  loop_control:
    label: "{{ item.host }} - {{ item.v4_address.address }}"
  vars:
    v4gateway_query: "[?item.address == `{{ item.v4_address.address}}`] |[0].stdout"
    v4gateway: "{{ ((ipAddress_gateways.results | json_query(v4gateway_query)).split('/'))[0] }}"
    v4_cidr_address: "{{ item.v4_address.address }}/{{ net_cidr_address | ipaddr('prefix') }}"
    net_cidr_address: "{{ item.v4_address.network }}/{{ item.v4_address.netmask }}"
    totalBandwidth_query: "[?item == `{{ item.iface_name }}`] | to_number([0].stdout)"
    totalBandwidth: "{{  iface_total_bandwidth.results | json_query(totalBandwidth_query)}}"

- name: Set Fact for all interfaces with required data for server creation
  set_fact: 
    dl_all_interfaces: "{{ (dl_all_interfaces | default({})) | combine({ item.0.key: [serverIfacePayload] }, recursive=True, list_merge='append') }}"
  loop: "{{ ifaceObject | subelements('value') }}"
  loop_control: 
    label: "{{ item.0.key }} - {{ item.1.name }}"
  vars: 
    ifaceObject_query: "[].{ key: host, value: [{name: iface_name, max_bandwidth: iface_total_bandwidth, mtu: to_number(mtu), ipAddresses: ({v4_address: [v4_address], v6_address: v6_addresses} | *[].{address: address, gateway: gateway, serviceAddress: is_service_address })}]}"
    ifaceObject: "{{ _dl_all_ifaces_tmp_5 | json_query(ifaceObject_query) }}"
    monitor_interface_query: "ipAddresses[] | [?serviceAddress == `true`]"
    monitor_interface: "{{ true if (item.1 | json_query(monitor_interface_query) | length) > 0 else false }}"
    serverIfacePayload: "{{ item.1 | combine({'monitor': monitor_interface, 'max_bandwidth': (max_bandwidth | int) }, recursive=True) }}"
    bandwidth: "{{ (item.1.max_bandwidth | default(1000, true)) | int }}"
    max_bandwidth_by_limit: "{{ bandwidth - (reserved_interface_bandwidth_lookup[bandwidth]) if reserved_interface_bandwidth_lookup is defined and reserved_interface_bandwidth_lookup[bandwidth] is defined }}"
    max_bandwidth_by_percent: "{{ (bandwidth|int) - ((bandwidth|int)/(reserved_interface_bandwidth_percent | default(80) | int )) }}"
    max_bandwidth: "{{ max_bandwidth_by_limit | default(max_bandwidth_by_percent,true) }}"

- name: Create Servers (Non-mso)
  uri:
    url: "{{ dl_to_url }}/api/{{ dl_to_api_version }}/servers"
    method: POST
    body: "{{ lookup('template', 'server.j2') }}"
  with_items: "{{ groups['all'] | difference(groups['mso_parent_alias']) }}"
  vars:
    error_query: "alerts[?level=='error'].text[?!contains(@,'already exists')]"
    status_name: "{{ status_assignment[item] | default('ONLINE') }}"
    status_query: "[?name == `{{ status_name }}`].id | [0]"
    status_id: "{{ get_all_statuses.json.response | to_json | from_json | json_query(status_query) }}"
    cachegroup_name: "{{ cachegroups_assignments[item] | default('infrastructure') }}"
    cachegroup_query: "[?name == `{{ cachegroup_name }}`].id | [0]"
    cachegroup_id: "{{ get_all_cachegroups.json.response | to_json | from_json | json_query(cachegroup_query) }}"
    location_name: "{{ physlocation_assignments[item] | default('Baltimore-MD') }}"
    location_query: "[?name == `{{ location_name }}`].id | [0]"
    location_id: "{{ get_all_physlocations.json.response | to_json | from_json | json_query(location_query) }}"
    type_name: "{{ type_assignments[item] | default('TRAFFIC_OPS_DB') }}"
    type_query: "[?name == `{{ type_name }}`].id | [0]"
    type_id: "{{ get_all_types.json.response | to_json | from_json | json_query(type_query) }}"
    lc_profiles: "{{ get_all_profiles.json.response | lower }}"
    profile_name: "{{ profile_assignments[item] | default('TRAFFIC_OPS_DB') }}"
    profile_query: "[?name == `{{ profile_name }}`].id | [0]"
    profile_id: "{{ lc_profiles | to_json | from_json | json_query(profile_query) }}"
    lc_cdns: "{{ get_all_cdns.json.response | lower }}"
    cdn_name: "{{ delegation_cdnName_map[cdn_assignments[item] | lower ] }}"
    cdn_query: "[?starts_with(name,`{{ cdn_name | lower }}`)].id | [0]"
    cdn_id: "{{ lc_cdns | to_json | from_json | json_query(cdn_query) }}"
    hostName: "{{ item.split('.')[0] }}"
    domainName: "{{ item.split('.')[1:] | join('.') }}"
    cachegroupId: "{{ cachegroup_id }}"
    statusId: "{{ status_id }}"
    physLocationId: "{{ location_id }}"
    typeId: "{{ type_id }}"
    profileId: "{{ profile_id }}"
    cdnId: "{{ cdn_id }}"
    updPending: True
    interfaces: "{{ dl_all_interfaces[item] }}"
    tcpPort: "{{ (dl_ds_merged_servers[item] | default(dl_ds_merged_servers['server.kabletown.invalid'])).tcpPort | default(omit) }}"
    httpsPort: "{{ (dl_ds_merged_servers[item] | default(dl_ds_merged_servers['server.kabletown.invalid'])).httpsPort | default(omit) }}"
    xmppId: "{{ (dl_ds_merged_servers[item] | default(dl_ds_merged_servers['server.kabletown.invalid'])).xmppId | default(omit) }}"
    xmppPasswd: "{{ (dl_ds_merged_servers[item] | default(dl_ds_merged_servers['server.kabletown.invalid'])).xmppPasswd | default(omit) }}"
    rack: "{{ (dl_ds_merged_servers[item] | default(dl_ds_merged_servers['server.kabletown.invalid'])).rack | default(omit) }}"
    mgmtIpAddress: "{{ (dl_ds_merged_servers[item] | default(dl_ds_merged_servers['server.kabletown.invalid'])).mgmtIpAddress | default(omit) }}"
    mgmtIpNetmask: "{{ (dl_ds_merged_servers[item] | default(dl_ds_merged_servers['server.kabletown.invalid'])).mgmtIpNetmask | default(omit) }}"
    mgmtIpGateway: "{{ (dl_ds_merged_servers[item] | default(dl_ds_merged_servers['server.kabletown.invalid'])).mgmtIpGateway | default(omit) }}"
    iloIpAddress: "{{ (dl_ds_merged_servers[item] | default(dl_ds_merged_servers['server.kabletown.invalid'])).iloIpAddress | default(omit) }}"
    iloIpNetmask: "{{ (dl_ds_merged_servers[item] | default(dl_ds_merged_servers['server.kabletown.invalid'])).iloIpNetmask | default(omit) }}"
    iloIpGateway: "{{ (dl_ds_merged_servers[item] | default(dl_ds_merged_servers['server.kabletown.invalid'])).iloIpGateway | default(omit) }}"
    iloUsername: "{{ (dl_ds_merged_servers[item] | default(dl_ds_merged_servers['server.kabletown.invalid'])).iloUsername | default(omit) }}"
    iloPassword: "{{ (dl_ds_merged_servers[item] | default(dl_ds_merged_servers['server.kabletown.invalid'])).iloPassword | default(omit) }}"
    routerHostName: "{{ (dl_ds_merged_servers[item] | default(dl_ds_merged_servers['server.kabletown.invalid'])).routerHostName | default(omit) }}"
    routerPortName: "{{ (dl_ds_merged_servers[item] | default(dl_ds_merged_servers['server.kabletown.invalid'])).routerPortName | default(omit) }}"
  register: create_server_out
  failed_when: (create_server_out.status == 400 and create_server_out.json | to_json | from_json | json_query(error_query) | length != 0) or (create_server_out.status > 400 and create_server_out.status < 600)

###
# MSO servers are not guarenteed to be idempotent
# There exists an order of execution issue with regard to doing DS creation last
# This prevents you from knowing how to associate DS -> Eligible Server Profiles -> Servers -> MSO DS Server Assignments
# At present you have Profiles -> Servers -> DS -> Update MSO Server Profiles (to match specified eligibility) -> MSO DS Server Assignments
# This being said, it's only a broken idempotency so for CI/One-n-done purposes, it still works
###

- name: Create Servers (MSO)
  uri:
    url: "{{ dl_to_url }}/api/{{ dl_to_api_version }}/servers"
    method: POST
    body: "{{ lookup('template', 'server.j2') }}"
  with_items: "{{ groups['mso_parent_alias'] }}"
  vars:
    error_query: "alerts[?level=='error'].text[?!contains(@,'already exists')]"
    status_name: "{{ status_assignment[item] | default('ONLINE') }}"
    status_query: "[?name == `{{ status_name }}`].id | [0]"
    status_id: "{{ get_all_statuses.json.response | to_json | from_json | json_query(status_query) }}"
    cachegroup_name: "{{ cachegroups_assignments[item] | default('infrastructure') }}"
    cachegroup_query: "[?name == `{{ cachegroup_name }}`].id | [0]"
    cachegroup_id: "{{ get_all_cachegroups.json.response | to_json | from_json | json_query(cachegroup_query) }}"
    location_name: "{{ physlocation_assignments[item] | default('Baltimore-MD') }}"
    location_query: "[?name == `{{ location_name }}`].id | [0]"
    location_id: "{{ get_all_physlocations.json.response | to_json | from_json | json_query(location_query) }}"
    type_name: "{{ type_assignments[item] | default('TRAFFIC_OPS_DB') }}"
    type_query: "[?name == `{{ type_name }}`].id | [0]"
    type_id: "{{ get_all_types.json.response | to_json | from_json | json_query(type_query) }}"
    lc_profiles: "{{ get_all_profiles.json.response | lower }}"
    profile_name: "{{ profile_assignments[item] | default('TRAFFIC_OPS_DB') }}"
    profile_query: "[?name == `{{ profile_name }}`].id | [0]"
    profile_id: "{{ lc_profiles | to_json | from_json | json_query(profile_query) }}"
    lc_cdns: "{{ get_all_cdns.json.response | lower }}"
    cdn_name: "{{ delegation_cdnName_map[cdn_assignments[item] | lower ] }}"
    cdn_query: "[?starts_with(name,`{{ cdn_name | lower }}`)].id | [0]"
    cdn_id: "{{ lc_cdns | to_json | from_json | json_query(cdn_query) }}"
    hostName: "{{ item.split('.')[0] }}"
    domainName: "{{ item.split('.')[1:] | join('.') }}"
    cachegroupId: "{{ cachegroup_id }}"
    statusId: "{{ status_id }}"
    physLocationId: "{{ location_id }}"
    typeId: "{{ type_id }}"
    profileId: "{{ profile_id }}"
    cdnId: "{{ cdn_id }}"
    updPending: True
    interfaces:
      - maxBandwidth: null
        monitor: true
        mtu: 9000
        name: "eth0"
        ipAddresses:
          - address: "{{ hostvars[item].ansible_host }}"
            gateway: "127.0.0.0"
            serviceAddress: true
    tcpPort: "{{ (dl_ds_merged_servers[item] | default(dl_ds_merged_servers['server.kabletown.invalid'])).tcpPort | default(omit) }}"
    httpsPort: "{{ (dl_ds_merged_servers[item] | default(dl_ds_merged_servers['server.kabletown.invalid'])).httpsPort | default(omit) }}"
    xmppId: "{{ (dl_ds_merged_servers[item] | default(dl_ds_merged_servers['server.kabletown.invalid'])).xmppId | default(omit) }}"
    xmppPasswd: "{{ (dl_ds_merged_servers[item] | default(dl_ds_merged_servers['server.kabletown.invalid'])).xmppPasswd | default(omit) }}"
    rack: "{{ (dl_ds_merged_servers[item] | default(dl_ds_merged_servers['server.kabletown.invalid'])).rack | default(omit) }}"
    mgmtIpAddress: "{{ (dl_ds_merged_servers[item] | default(dl_ds_merged_servers['server.kabletown.invalid'])).mgmtIpAddress | default(omit) }}"
    mgmtIpNetmask: "{{ (dl_ds_merged_servers[item] | default(dl_ds_merged_servers['server.kabletown.invalid'])).mgmtIpNetmask | default(omit) }}"
    mgmtIpGateway: "{{ (dl_ds_merged_servers[item] | default(dl_ds_merged_servers['server.kabletown.invalid'])).mgmtIpGateway | default(omit) }}"
    iloIpAddress: "{{ (dl_ds_merged_servers[item] | default(dl_ds_merged_servers['server.kabletown.invalid'])).iloIpAddress | default(omit) }}"
    iloIpNetmask: "{{ (dl_ds_merged_servers[item] | default(dl_ds_merged_servers['server.kabletown.invalid'])).iloIpNetmask | default(omit) }}"
    iloIpGateway: "{{ (dl_ds_merged_servers[item] | default(dl_ds_merged_servers['server.kabletown.invalid'])).iloIpGateway | default(omit) }}"
    iloUsername: "{{ (dl_ds_merged_servers[item] | default(dl_ds_merged_servers['server.kabletown.invalid'])).iloUsername | default(omit) }}"
    iloPassword: "{{ (dl_ds_merged_servers[item] | default(dl_ds_merged_servers['server.kabletown.invalid'])).iloPassword | default(omit) }}"
    routerHostName: "{{ (dl_ds_merged_servers[item] | default(dl_ds_merged_servers['server.kabletown.invalid'])).routerHostName | default(omit) }}"
    routerPortName: "{{ (dl_ds_merged_servers[item] | default(dl_ds_merged_servers['server.kabletown.invalid'])).routerPortName | default(omit) }}"
  register: create_server_out
  failed_when: (create_server_out.status == 400 and create_server_out.json | to_json | from_json | json_query(error_query) | length != 0) or (create_server_out.status > 400 and create_server_out.status < 600)

- name: Get All Servers
  uri:
    url: "{{ dl_to_url }}/api/{{ dl_to_api_version }}/servers"
    method: GET
  register: get_all_servers

- name: Convert the CDN Delegation list into an index
  set_fact:
    cdnDelegationIndex: "{{ (cdnDelegationIndex | default({}) ) | combine( { item.1: item.0 } ) }}"
  with_indexed_items: "{{ cdnDelegationList | sort | unique }}"

- name: Create Index of Fake Origins
  set_fact:
    foIndex: "{{ (foIndex | default({}) ) | combine( { item.1: item.0 } ) }}"
  with_indexed_items: "{{ groups['fakeorigin'] }}"

- name: Assert we have enough Delivery Service CName records to go around
  assert:
    that:
      - (hostvars[groups['fakeorigin'] | first].ds_names.split(',') | length) >= (dl_ds_merged_ds_template | length)
    success_msg: "Enough Delivery CNames Exist ({{ dl_ds_merged_ds_template | length }}/{{ hostvars[groups['fakeorigin'] | first].ds_names.split(',') | length }})"
    fail_msg: "Not enough DS CNames exist to cover all DS.  Please go and create {{ (dl_ds_merged_ds_template | length) - (hostvars[groups['fakeorigin'] | first].ds_names.split(',') | length) }} more and rerun."
  vars:
    Target_cdn_delegation: Invalid (just for rendering)

- name: Handle Delivery Service CDN Templates
  include_tasks: ds_loader.yml
  vars:
    Target_cdn_delegation_fqdn: "{{ Target_cdn_delegation | default(MKGA) }}.{{ (groups['traffic_ops'] | first).split('.')[1:] | join('.') | lower }}"
    Target_cdn_name: "{{ get_all_cdns.json | to_json | from_json | json_query(cdnName_query) }}"
    Target_cdn_id: "{{ get_all_cdns.json | to_json | from_json | json_query(cdn_query) }}"
    cdnName_query: "response[?starts_with(domainName,`{{ Target_cdn_delegation | lower }}`) == `true`].name | [0]"
    cdn_query: "response[?starts_with(domainName,`{{ Target_cdn_delegation | lower }}`) == `true`].id | [0]"
  with_items: "{{ cdnDelegationList }}"
  loop_control:
    loop_var: Target_cdn_delegation

- name: Get All Delivery Services
  uri:
    url: "{{ dl_to_url }}/api/{{ dl_to_api_version }}/deliveryservices"
    method: GET
  register: get_all_ds

- name: Render Federations Lists
  with_items: "{{ cdnDelegationList }}"
  loop_control:
    loop_var: Target_cdn_delegation
  set_fact:
    federations_for_cdn_delegation: "{{ dl_ds_default_federations }}"
  register: federations_out

- name: Create Federations
  vars:
    federations_query: 'results[].ansible_facts[].federations_for_cdn_delegation[]'
  with_items: "{{ federations_out | json_query(federations_query) }}"
  loop_control:
    loop_var: federation
  include_tasks: federation_loader.yml

- name: Ensure SSL info directory exists
  file:
    state: directory
    path: "{{ lookup('env', 'PWD') }}/out/ssl"

- name: Set a default list of HTTPS DS
  set_fact:
    scrubbed_https_ds: []

- name: Scrub the protocol out of HTTS DS URLs
  set_fact:
    scrubbed_https_ds: "{{ scrubbed_https_ds | default([]) + [ combined ] }}"
  with_items: "{{ get_all_ds.json | to_json | from_json | json_query(https_query) }}"
  vars:
    https_query: "response[?protocol >= `2` ].{ xmlId: xmlId, exampleURLs: exampleURLs[? starts_with(@, `https`) ], cdnName: cdnName, is_http: ( contains(type, `HTTP`) ) }"
    fqdns: "{{ item.exampleURLs | map('regex_replace', 'https://^(.*)', '\\1') | list }}"
    base_fqdns: "{{ fqdns | map('regex_replace', '.*?\\.(.*)', 'DNS:\\1') | list }}"
    sans: "{% if item.is_http %}{{ (fqdns | map('regex_replace', '.*?\\.(.*)', 'DNS:*.\\1') | list) + base_fqdns }}{% else %}{{ fqdns | map('regex_replace', '^(.*)', 'DNS:\\1') | list }}{% endif %}"
    combined: "{{ item | combine( {'fqdns': fqdns, 'sans': sans} ) }}"

- name: Generate DS Private keys
  openssl_privatekey:
    path: "{{ lookup('env', 'PWD') }}/out/ssl/{{ item.xmlId }}.key.pem"
    force: yes
  with_items: "{{ scrubbed_https_ds }}"

- name: Generate DS CSRs
  openssl_csr:
    privatekey_path: "{{ lookup('env', 'PWD') }}/out/ssl/{{ item.xmlId }}.key.pem"
    subject:
      CN: "{{ (item.sans | first).split(':')[1] }}"
      C: US
      ST: Colorado
      L: Denver
      O: Kabletown
      OU: CDN
      emailAddress: Ops@kabletown.invalid
    subject_alt_name: "{{ item.sans }}"
    key_usage:
      - digitalSignature
      - keyEncipherment
    extended_key_usage:
      - serverAuth
    basic_constraints:
      - CA:FALSE
    path: "{{ lookup('env', 'PWD') }}/out/ssl/{{ item.xmlId }}.csr"
    force: yes
  with_items: "{{ scrubbed_https_ds }}"

- name: Generate DS Certificates
  openssl_certificate:
    csr_path: "{{ lookup('env', 'PWD') }}/out/ssl/{{ item.xmlId }}.csr"
    force: yes
    issuer:
      CN: CDNLAB.invalid
      C: US
      ST: Colorado
      L: Denver
      O: Kabletown
      OU: CDN
    path: "{{ lookup('env', 'PWD') }}/out/ssl/{{ item.xmlId }}.crt"
    privatekey_path: "{{ lookup('env', 'PWD') }}/out/ssl/{{ item.xmlId }}.key.pem"
    provider: ownca
    ownca_path: "{{ lookup('env', 'PWD') }}/out/ssl/lab.intermediateca.crt"
    ownca_privatekey_path: "{{ lookup('env', 'PWD') }}/out/ssl/lab.intermediateca.key.pem"
  with_items: "{{ scrubbed_https_ds }}"

- name: Generate TO Self-signed certs
  uri:
    url: "{{ dl_to_url }}/api/{{ dl_to_api_version }}/deliveryservices/sslkeys/generate"
    method: POST
    body:
      cdn: "{{ item.cdnName }}"
      city: Denver
      country: US
      hostname: "{{ (item.sans | first).split(':')[1] }}"
      key: "{{ item.xmlId }}"
      organization: Kabletown
      state: CO
      businessUnit: CDN
      deliveryservice: "{{ item.xmlId }}"
      version: 1
  with_items: "{{ scrubbed_https_ds }}"

- name: Upload DS SSL Data to Traffic Ops
  uri:
    url: "{{ dl_to_url }}/api/{{ dl_to_api_version }}/deliveryservices/sslkeys/add"
    method: POST
    body:
      key: "{{ item.xmlId }}"
      version: 2
      cdn: "{{ item.cdnName }}"
      hostname: "{{ (item.sans | first).split(':')[1] }}"
      certificate:
        key: "{{ lookup('file', keypath) }}"
        csr: "{{ lookup('file', csrpath) }}"
        crt: |
          {{ lookup('file', crtpath) }}
          {{ lookup('file', intcertpath) }}
  with_items: "{{ scrubbed_https_ds }}"
  register: create_ds_sslkeys_out
  failed_when: (create_ds_sslkeys_out.status == 400 and create_ds_sslkeys_out.json | to_json | from_json | json_query(error_query) | length != 0) or (create_ds_sslkeys_out.status > 400 and create_ds_sslkeys_out.status < 600)
  vars:
    error_query: "alerts[?level=='error'].text[?!contains(@,'already exists')]"
    keypath: "{{ lookup('env', 'PWD') }}/out/ssl/{{ item.xmlId }}.key.pem"
    csrpath: "{{ lookup('env', 'PWD') }}/out/ssl/{{ item.xmlId }}.csr"
    crtpath: "{{ lookup('env', 'PWD') }}/out/ssl/{{ item.xmlId }}.crt"
    intcertpath: "{{ lookup('env', 'PWD') }}/out/ssl/lab.intermediateca.crt"

- name: Snapshot all CDNs
  uri:
    url: "{{ dl_to_url }}/api/{{ dl_to_api_version }}/snapshot?cdn={{ item.name }}"
    method: PUT
  with_items: "{{ get_all_cdns.json.response[1:] }}"
  register: snapshot_out
  failed_when: (snapshot_out.status == 400 and snapshot_out.json | to_json | from_json | json_query(error_query) | length != 0) or (snapshot_out.status > 400 and snapshot_out.status < 600)
  vars:
    error_query: "alerts[?level=='error'].text[?!contains(@,'already exists')]"
